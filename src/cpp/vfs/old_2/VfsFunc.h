#pragma once

//#include "types_of_keys_of_vfs_objects.h"
#include "../support/CtStringList.h" // IWYU pragma: export
#include "../support/CtIntList.h" // IWYU pragma: export
#include "VfsFuncArray.h"
#include "VfsWrapper.h" // IWYU pragma: export

BEG_VFS_NAMESPACE

/// generic definition
template<CtStringValue name,class CompilationFlags,class OutputIndices,class... Args>
class VfsFunc {
public:
    static constexpr PI nb_vfs_wrappers = ( IsAVfsWrapper<Args> + ... );
    using               Callable        = void( Args... );
    using               Array           = VfsFuncArray<Callable,nb_vfs_wrappers>;

    /**/                VfsFunc         ();

    void                operator()      ( Args ...args );

    TA static Callable* callable_for    ( const A &...args );
    static void         init            ( Args ...args );

    Array               array;          ///<
};

/// call code generated by a surdef
template<CtStringValue name,CtStringValue... compilations_flags,int... output_indices,class ReturnType,class... Args>
auto vfs_call( CtString<name>, CtStringList<compilations_flags...>, CtIntList<output_indices...>, CtType<ReturnType>, Args&&... args );

/// helper to call code generated by a surdef
#define VFS_CALL( FUNC, COMP_FLAGS, RETURN, ... ) \
    vfs_call< #FUNC, COMP_FLAGS, RETURN >( __VA_ARGS__ )

/// helper to call a method which code is generated by a surdef (self is assumed to be the first arg)
#define VFS_CALL_METHOD( FUNC, RETURN, ... ) \
    vfs_call< #FUNC "__method", CtStringList<>, RETURN >( __VA_ARGS__ )

/// helper to call a method on _cast of first arg which code is generated by a surdef (self is assumed to be the first arg)
#define VFS_CALL_CAST_METHOD( FUNC, RETURN, ... ) \
    vfs_call< #FUNC "__cast_method", CtStringList<>, RETURN >( __VA_ARGS__ )

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct call. Else, use a vfs_call
#define VFS_CALL_DINK( FUNC, COMPILATION_FLAGS, OUTPUT_INDICES, RETURN_TYPE, ... ) \
    ( [&]<class Cf,class Oi,class Rt,class... Args>( const Cf &compilation_flags, const Oi &output_indices, class Rt &return_type, Args&&...args ) -> RETURN_TYPE { \
        if constexpr ( IsAVfsWrapper<Cf> || IsAVfsWrapper<Oi> || IsAVfsWrapper<Rt> || ( IsAVfsWrapper<Args> || ... ) ) \
            return vfs_call( CtFuncInfo<#FUNC>(), compilation_flags, output_indices, return_type, std::forward<Args>( args )... ); \
        else \
            return FUNC( std::forward<Args>( args )... ); \
    } )( COMPILATION_FLAGS, OUTPUT_INDICES, RETURN_TYPE, __VA_ARGS__ )

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct method call. Else, use a vfs_call
#define VFS_CALL_METHOD_DINK( FUNC, RETURN, SELF, ... ) \
    ( [&]<class Self,class... Args>( Self &&self, Args&&...args ) { \
        if constexpr ( VfsWrapper<Self> || ( VfsWrapper<Args> || ... ) ) \
            return vfs_call<#FUNC "__method",CtStringList<>,RETURN>( std::forward<Self>( self ), std::forward<Args>( args )... ); \
        else \
            return self.FUNC( std::forward<Args>( args )... ); \
    } )( SELF, __VA_ARGS__ )


///
#define VFS_CALL_METHOD_WITH_CATCH( FUNC, RETURN, SELF, ... ) \
    ( [&]<class Self,class... Args>( Self &&self, Args&&...args ) { \
        for( PI i = 0; i < 10; ++i ) { \
            try { \
                return vfs_call<#FUNC "__method",CtStringList<>,RETURN>( std::forward<Self>( self ), std::forward<Args>( args )... ); \
            } catch ( const VFS_NAMESPACE::VfsTypeException &e ) { \
                e.change_type_of( &self ); \
            } \
        } \
        ERROR( "no stable target type" ); \
    } )( SELF, __VA_ARGS__ )

END_VFS_NAMESPACE

#include "VfsFunc.tcc" // IWYU pragma: export
