#pragma once

#include "types_of_keys_of_vfs_objects.h"
#include "../support/CtStringList.h" // IWYU pragma: export
#include "VfsFuncArray.h"
#include "VfsArg.h" // IWYU pragma: export

BEG_VFS_NAMESPACE

/// generic definition
template<CtStringValue name,class Flags,class Return,class... Args>
class VfsFunc {
public:
    using               Callable    = Return( Args... );
    using               KeyList     = decltype( types_of_keys_of_vfs_objects( CtTypeList<>{}, CtTypeList<Args...>{} ) );
    using               Array       = VfsFuncArray<KeyList,Callable>;

    /**/                VfsFunc     ();

    Return              operator()  ( Args ...args );

    TA static Callable* callable_for( const A &...args );
    static Return       init        ( Args ...args );

    Array               array;      ///<
};

/// concept to test if an object is going to produce a different "real" type in the generated code
// TT concept VfsArg = requires ( const T &t ) { vfs_object_ct_key( t ); };

/// call code generated by a surdef
template<CtStringValue name,class Flags,class Return,class... Args>
auto vfs_call( Args&&... args );

/// helper to call code generated by a surdef
#define VFS_CALL( FUNC, COMP_FLAGS, RETURN, ... ) \
    vfs_call< #FUNC, COMP_FLAGS, RETURN >( __VA_ARGS__ )

/// helper to call a method which code is generated by a surdef (self is assumed to be the first arg)
#define VFS_CALL_METHOD( FUNC, COMP_FLAGS, RETURN, ... ) \
    vfs_call< #FUNC "__method", COMP_FLAGS, RETURN >( __VA_ARGS__ )

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct call. Else, use a vfs_call
#define VFS_CALL_DINK( FUNC, COMP_FLAGS, RETURN, ... ) \
    ( [&]<class... Args>( Args&&...args ) { \
        if constexpr ( ( VfsArg<Args> || ... ) ) \
            return vfs_call<#FUNC,COMP_FLAGS,RETURN>( std::forward<Args>( args )... ); \
        else \
            return FUNC( std::forward<Args>( args )... ); \
    } )( __VA_ARGS__ );

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct method call. Else, use a vfs_call
#define VFS_CALL_METHOD_DINK( FUNC, COMP_FLAGS, RETURN, SELF, ... ) \
    ( [&]<class Self,class... Args>( Self &&self, Args&&...args ) { \
        if constexpr ( VfsArg<Self> || ( VfsArg<Args> || ... ) ) \
            return vfs_call<#FUNC "__method",COMP_FLAGS,RETURN>( std::forward<Self>( self ), std::forward<Args>( args )... ); \
        else \
            return self.FUNC( std::forward<Args>( args )... ); \
    } )( SELF, __VA_ARGS__ );

END_VFS_NAMESPACE

#include "VfsFunc.tcc" // IWYU pragma: export
