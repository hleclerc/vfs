#pragma once

//#include "types_of_keys_of_vfs_objects.h"
#include "../support/operators/add.h"
#include "../support/CtStringList.h" // IWYU pragma: export
#include "apply_on_vfs_objects.h"
#include "VfsFuncArray.h"
#include "IsAVfsObject.h"

BEG_VFS_NAMESPACE

/// generic definition
template<CtStringValue name,class CompilationFlags,class Return,class... Args>
class VfsFunc {
public:
    static constexpr PI nb_vfs_objects = add( IsAVfsObject<Args>... );
    using               Callable       = Return( Args... );
    using               Array          = VfsFuncArray<Callable,nb_vfs_objects>;

    /**/                VfsFunc        ();

    Return              operator()     ( Args ...args );

    TA static Callable* callable_for   ( const A &...args );
    static Return       init           ( Args ...args );

    Array               array;         ///<
};

/// call code generated by a surdef
template<CtStringValue name,class CompilationFlags,class Return,class... Args>
auto vfs_call( Args&&... args );

/// helper to call code generated by a surdef
#define VFS_CALL( FUNC, COMP_FLAGS, RETURN, ... ) \
    vfs_call< #FUNC, COMP_FLAGS, RETURN >( __VA_ARGS__ )

/// helper to call a method which code is generated by a surdef (self is assumed to be the first arg)
#define VFS_CALL_METHOD( FUNC, RETURN, ... ) \
    vfs_call< #FUNC "__method", CtStringList<>, RETURN >( __VA_ARGS__ )

/// helper to call a method on _cast of first arg which code is generated by a surdef (self is assumed to be the first arg)
#define VFS_CALL_CAST_METHOD( FUNC, RETURN, ... ) \
    vfs_call< #FUNC "__cast_method", CtStringList<>, RETURN >( __VA_ARGS__ )

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct call. Else, use a vfs_call
#define VFS_CALL_DINK( FUNC, COMP_FLAGS, RETURN, ... ) \
    ( [&]<class... Args>( Args&&...args ) { \
        if constexpr ( ( VfsArg<Args> || ... ) ) \
            return vfs_call<#FUNC,COMP_FLAGS,RETURN>( std::forward<Args>( args )... ); \
        else \
            return FUNC( std::forward<Args>( args )... ); \
    } )( __VA_ARGS__ )

/// if args do not generate any ct_key (vfs_object_ct_key), make a direct method call. Else, use a vfs_call
#define VFS_CALL_METHOD_DINK( FUNC, RETURN, SELF, ... ) \
    ( [&]<class Self,class... Args>( Self &&self, Args&&...args ) { \
        if constexpr ( VfsArg<Self> || ( VfsArg<Args> || ... ) ) \
            return vfs_call<#FUNC "__method",CtStringList<>,RETURN>( std::forward<Self>( self ), std::forward<Args>( args )... ); \
        else \
            return self.FUNC( std::forward<Args>( args )... ); \
    } )( SELF, __VA_ARGS__ )


///
#define VFS_CALL_METHOD_WITH_CATCH( FUNC, RETURN, SELF, ... ) \
    ( [&]<class Self,class... Args>( Self &&self, Args&&...args ) { \
        for( PI i = 0; i < 10; ++i ) { \
            try { \
                return vfs_call<#FUNC "__method",CtStringList<>,RETURN>( std::forward<Self>( self ), std::forward<Args>( args )... ); \
            } catch ( const VFS_NAMESPACE::VfsTypeException &e ) { \
                e.change_type_of( &self ); \
            } \
        } \
        ERROR( "no stable target type" ); \
    } )( SELF, __VA_ARGS__ )

END_VFS_NAMESPACE

#include "VfsFunc.tcc" // IWYU pragma: export
